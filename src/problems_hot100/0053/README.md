# DP 入门指南

### 第一站：什么是动态规划 (Dynamic Programming, DP)？

忘掉那些复杂的定义，我们先用一个比喻来理解。

**想象一下你在玩一个爬楼梯的游戏：**

> 你要爬一个 n 级的楼梯，每次你只能爬 1 级或者 2 级。请问爬到第 n 级楼梯一共有多少种方法？

  * 要想到达第 n 级，你上一步必然是在第 `n-1` 级或者第 `n-2` 级。
  * 所以，到达第 n 级的方法数 = (到达第 `n-1` 级的方法数) + (到达第 `n-2` 级的方法数)。

你看，我们把一个“大问题”（如何到第 n 级）分解成了两个“小一点的、但结构相同的问题”（如何到 `n-1` 级和 `n-2` 级）。并且，我们在计算大问题的时候，直接利用了小问题的答案。

这就是**动态规划的核心思想**：

1.  **（拆分）拆分问题**：把一个复杂问题拆解成一连串更小的、相似的子问题。
2.  **（暂存）记住答案**：把每个小问题的答案“存”起来，避免重复计算。
3.  **（递推）递推求解**：从最小的子问题开始，一步步地利用已经算出的答案，推导出更大问题的答案，直到解决原始问题。

-----

### 第二站：用动态规划“三步走”解决“最大子序和”

现在，我们用这个思想来解剖“最大子序和”这道题。题目要求一个数组中，和最大的**连续**子数组。

我们遵循动态规划的经典“三步走”策略：

#### 第 1 步：定义状态 (State)

这是 DP 中最最关键的一步！我们要定义一个“状态”，这个状态要能描述子问题的解。在官方题解里，这个状态就是 `f(i)`。

  * **`f(i)` 代表什么？**
      * 官方定义：以第 `i` 个数**结尾**的「连续子数组的最大和」。
      * **大白话解释**：我们考察数组 `nums` 的第 `i` 个元素 `nums[i]`。所有包含 `nums[i]` 并且以它为**最后一个元素**的连续子数组中，哪个的和最大？这个最大值就是 `f(i)`。

**【敲黑板】**：初学者最容易犯的错，就是把 `f(i)` 理解成“前 i 个数的最大子序和”。这是不对的！`f(i)` 强调的是 **“必须以 `nums[i]` 结尾”**。

#### 第 2 步：找出状态转移方程 (Transition Equation)

这一步是寻找“大问题”和“小问题”之间的数学关系。我们要计算 `f(i)`，怎么利用我们已经知道的“历史信息”（比如 `f(i-1)`）呢？

我们站在 `nums[i]` 的位置思考，要构成一个以 `nums[i]` 结尾的连续子数组，只有两种可能：

1.  **`nums[i]` 自成一派**：前面的都不要了，就从我 `nums[i]` 开始，形成一个新的子数组。此时，这个子数组的和就是 `nums[i]`。
2.  **`nums[i]` 加入组织**：`nums[i]` 决定加入它前面的那个“以 `nums[i-1]` 结尾的最大和子数组”。这个子数组的和是 `f(i-1)`。`nums[i]` 加进来后，新的和就变成了 `f(i-1) + nums[i]`。

`f(i)` 的目标是求“最大和”，所以它肯定会选择上面两种情况中，结果更大的那个。于是，状态转移方程就诞生了：

$$f(i) = \max\{f(i-1) + \text{nums}[i], \text{nums}[i]\}$$

#### 第 3 步：确定初始条件 (Base Case) 和最终答案

  * **初始条件**：`f(0)` 是什么？根据定义，`f(0)` 是以 `nums[0]` 结尾的连续子数组的最大和。因为只有一个元素，所以 `f(0)` 就等于 `nums[0]`。
  * **最终答案**：我们求了一串 `f(0), f(1), f(2), ..., f(n-1)`。哪个是最终答案？
      * 记住，`f(i)` 只是以 `nums[i]` 结尾的最大和。但整个数组的最大子序和可能在任何地方结束。
      * 例如，对于 `[1, 2, -10, 4]`，最大子序和是 `[1, 2]`，和为 3，它在 `i=1` 的位置结尾。而 `f(3)` 只是 `4`。
      * 所以，**最终答案是所有 `f(i)` 中的最大值**：$\max{\{f(0), f(1), \dots, f(n-1)\}}$。

**让我们用一个例子 `nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]` 走一遍：**

| i | nums[i] | `f(i-1) + nums[i]` | `nums[i]` | `f(i) = max(...)` |
|---|---|---|---|---|
| 0 | -2 | (无 `f(-1)`) | -2 | **-2** |
| 1 | 1 | `-2 + 1 = -1` | 1 | **1** |
| 2 | -3 | `1 + (-3) = -2` | -3 | **-2** |
| 3 | 4 | `-2 + 4 = 2` | 4 | **4** |
| 4 | -1 | `4 + (-1) = 3` | -1 | **3** |
| 5 | 2 | `3 + 2 = 5` | 2 | **5** |
| 6 | 1 | `5 + 1 = 6` | 1 | **6** |
| 7 | -5 | `6 + (-5) = 1` | -5 | **1** |
| 8 | 4 | `1 + 4 = 5` | 4 | **5** |

我们得到的 `f` 数组是 `[-2, 1, -2, 4, 3, 5, 6, 1, 5]`。这里面的最大值是 **6**。这就是最终答案！

-----

### 第三站：什么是滚动数组 (Rolling Array)？

现在，你已经完全理解了上面的 DP 解法。这个解法需要一个 `f` 数组来存储每个 `f(i)` 的值，空间复杂度是 $O(n)$。

我们再回头看看那个神奇的状态转移方程：
$$f(i) = \max\{f(i-1) + \text{nums}[i], \text{nums}[i]\}$$

**你有没有发现一个秘密？**
要计算 `f(i)`，我们**唯一**需要用到的历史信息就是 `f(i-1)`。跟 `f(i-2)`, `f(i-3)` ... 完全没关系！

这就好比你每天记账，你只想知道“今天的余额”。你只需要“昨天的余额”和“今天的收入/支出”就能算出来，你完全不需要翻看上个月的账本。

**🌟🌟🌟滚动数组（或者叫状态压缩）就是基于这个发现的优化技巧。**

既然我们每次计算只需要前一个状态，何必用一个长长的数组 `f` 来存下所有历史记录呢？我们只需要一个变量，来“滚动”着记录**前一个**状态的值就行了。

#### 从 DP 到滚动数组的演变

我们来看题解里的代码：

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = 0; // 这个 pre 就是我们的滚动变量，相当于 f(i-1)
        int maxAns = nums[0]; // 这个用来记录全局的最大值，即 max(f(i))
        
        for (const auto &x : nums) {
            // 下面这行就是实现了状态转移方程
            // pre + x  就是 f(i-1) + nums[i]
            // x        就是 nums[i]
            pre = max(pre + x, x); 
            
            // 下面这行用来更新全局最大值
            maxAns = max(maxAns, pre);
        }
        return maxAns;
    }
};
```

**代码逻辑剖析：**

1.  `pre`：这个变量就是我们的“滚动”变量。在循环的每一次开始时，`pre` 存储的是上一个位置的 `f(i-1)` 的值。当 `pre = max(pre + x, x);` 执行后，`pre` 的值就被更新成了当前位置的 `f(i)`。在下一次循环中，它又自然而然地成为了新的 `f(i-1)`。
2.  `maxAns`：这个变量就是我们之前说的，用来在所有 `f(i)` 中寻找最大值的。每当我们计算出一个新的 `f(i)`（也就是新的 `pre`），就立刻用它来更新 `maxAns`。

通过这种方式，我们用一个变量 `pre` 代替了整个 `f` 数组，成功地把空间复杂度从 $O(n)$ 降到了 $O(1)$，而时间复杂度保持 $O(n)$ 不变。这就是滚动数组的魔力！

-----


上述文章解答了：如何用动态规划解决“最大子序和”的完整思想，以及如何用滚动数组进行空间优化。

**核心要点回顾：**

1.  **动态规划**是“拆分-记录-递推”的思想。
2.  **DP三步走**：定义状态（`f(i)` 的含义是关键）、找转移方程（`f(i)` 和 `f(i-1)` 的关系）、定初始和最终解。
3.  **滚动数组**是一种优化，当你发现计算当前状态只需要前面**有限个**（通常是1个或2个）状态时，就可以用几个变量来代替整个DP数组，以节省空间。

---
# 参考资料
- Google Gemini 2.5 Pro