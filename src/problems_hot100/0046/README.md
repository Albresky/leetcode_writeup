# [mid] #0046 全排列

## 思路：

关键是需要回溯，**恢复现场！**

### 法一：记录已选择数的路径

***

### 法二：Swap 交换法

**时空复杂度：$O_t(n)$, $O_s(1)$**

核心思想：**按顺序为每个位置挑选一张牌。**

我们从左到右，一个一个位置来确定要放哪个数字。
- 先确定第 0 个位置放谁。
- 再确定第 1 个位置放谁。
- ...
- 直到所有位置都确定下来。

### 用一个实例 `nums = [1, 2, 3]` 来走一遍

`backtrack(index, nums, result)` 函数的使命是：**“请帮我确定从 `index` 位置开始，后面所有位置的全排列”**。

---

#### **第一步：确定第 0 位 (调用 `backtrack(0, [1, 2, 3], ...)` )**

-   **目标**：为 `nums[0]` 这个位置选一个数。
-   **可选的数**：`[1, 2, 3]` 里的任何一个数都可以。
-   **如何选择**：通过循环，让 `1`、`2`、`3` 都有机会被放到第 0 位。这个“放”的动作，就是通过**交换**实现的。

    -   **尝试1：让 `1` 待在第 0 位**
        -   `for` 循环 `i = 0`。
        -   **选择**：交换 `nums[0]` 和 `nums[0]` (自己和自己换，数组不变)。
        -   **当前牌序**：`[1, 2, 3]`。 `// 第 0 位已经固定为 1`
        -   **下一步**：很好，第 0 位搞定了。现在我需要解决第 1 位以及之后位置的排列问题了。于是，调用 `backtrack(1, [1, 2, 3], ...)`。 (进入下一层递归)

    -   **尝试2：让 `2` 待在第 0 位** (这会在尝试1的所有子问题都解决完之后发生)
        -   `for` 循环 `i = 1`。
        -   **选择**：交换 `nums[0]` 和 `nums[1]`。
        -   **当前牌序**：`[2, 1, 3]`。 `// 第 0 位已经固定为 2`
        -   **下一步**：调用 `backtrack(1, [2, 1, 3], ...)`。

    -   **尝试3：让 `3` 待在第 0 位** (同理)
        -   `for` 循环 `i = 2`。
        -   **选择**：交换 `nums[0]` 和 `nums[2]`。
        -   **当前牌序**：`[3, 2, 1]`。 `// 第 0 位已经固定为 3`
        -   **下一步**：调用 `backtrack(1, [3, 2, 1], ...)`。

---

#### **第二步：深入其中一条线，看“回溯”如何发生**

我们只看上面“尝试1”的后续：

现在我们调用了 `backtrack(1, [1, 2, 3], ...)`。

-   **当前状态**：牌序是 `[1, 2, 3]`，`1` 已经被固定在第 0 位。
-   **目标**：为 `nums[1]` 这个位置选一个数。
-   **可选的数**：只能从第 1 位及之后的数里选，也就是从 `[2, 3]` 里选。

    -   **尝试1.1：让 `2` 待在第 1 位**
        -   `for` 循环 `i = 1`。
        -   **选择**：交换 `nums[1]` 和 `nums[1]` (自己和自己换)。
        -   **当前牌序**：`[1, 2, 3]`。 `// 第 1 位已经固定为 2`
        -   **下一步**：调用 `backtrack(2, [1, 2, 3], ...)`。

        -   **深入 `backtrack(2, ...)`:**
            -   **目标**：为 `nums[2]` 选一个数。
            -   **可选的数**：只有 `[3]`。
            -   **选择**：`i=2`，交换 `nums[2]` 和 `nums[2]`。牌序 `[1, 2, 3]`。
            -   **下一步**：调用 `backtrack(3, ...)`。
            -   **`backtrack(3, ...)` 触发终止条件**：`index == 3`。我们找到了一个完整排列 `[1, 2, 3]`，存入结果！然后返回。

        -   **返回到 `backtrack(2, ...)`:** `i=2` 的循环结束了。
        -   **！！！关键的回溯点！！！** 在 `backtrack(2, ...)` 函数结束前，它必须**恢复现场**！它当初进来时 `i=2`，交换了 `nums[2]` 和 `nums[2]`，现在它必须换回来。
        -   **撤销**：再次交换 `nums[2]` 和 `nums[2]`。牌序还是 `[1, 2, 3]`。函数返回。

    -   **返回到 `backtrack(1, ...)`:** 我们刚从 `backtrack(2,...)` 返回。现在我们知道，当第1位是 `2` 时所有可能都探索完了。
    -   **！！！关键的回溯点！！！** 程序要继续 `for` 循环的下一次 `i=2` 迭代了。但在那之前，必须**撤销** `i=1` 时做的选择。
    -   **撤销**：再次交换 `nums[1]` 和 `nums[1]`。牌序 `[1, 2, 3]`。

    -   **尝试1.2：让 `3` 待在第 1 位**
        -   `for` 循环 `i = 2`。
        -   **选择**：交换 `nums[1]` 和 `nums[2]`。
        -   **当前牌序**：`[1, 3, 2]`。 `// 第 1 位已经固定为 3`
        -   **下一步**：调用 `backtrack(2, [1, 3, 2], ...)`。
        -   ... 这条路会找到排列 `[1, 3, 2]` ...
        -   **撤销**：当 `backtrack(2,...)` 返回后，再次交换 `nums[1]` 和 `nums[2]`，牌序恢复为 `[1, 2, 3]`。

当 `backtrack(1, ...)` 的 `for` 循环（`i` 从 1 到 2）结束后，它也必须撤销它上层给它的状态。它会返回到 `backtrack(0, ...)`。

### 总结两个`swap`的意义

在 `for (int i = index; ...)` 循环中：

1.  `std::swap(nums[index], nums[i]);`  **(选择)**
    -   **目的**：这是做选择。它说：“我想试试把 `nums[i]` 这个数放到 `index` 这个位置上，看看后续能产生什么排列。”

2.  `backtrack(index + 1, ...);` **(前进)**
    -   **目的**：基于上面的选择，去解决规模更小的问题（确定 `index + 1` 位置）。

3.  `std::swap(nums[index], nums[i]);`  **(撤销/回溯)**
    -   **目的**：这是恢复现场。它说：“好了，我已经探索完把 `nums[i]` 放在 `index` 位置的所有可能性了。现在我必须把它换回去，**让数组恢复原样**，这样下一次循环（`i` 增加 1）才能在一个干净的、没有被修改过的状态下进行新的选择。”

如果缺少了第二个 `swap`（撤销操作），那么下一次循环就会在一个被“污染”的数组上进行，最终结果就会完全错误。
